<script type="module">
  // Firebase SDKs (modular)
  import { initializeApp, getApps, getApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getAuth,
    GoogleAuthProvider,
    signInWithPopup,
    onAuthStateChanged,
    signOut as fbSignOut,
    setPersistence,
    browserSessionPersistence
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
  import {
    getFirestore,
    collection,
    addDoc,
    getDocs,
    query,
    orderBy,
    serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

  // ====== CONFIG FIREBASE (usa a sua, não mexe no design) ======
  const firebaseConfig = window.firebaseConfig || {
    apiKey: "SUA_API_KEY",
    authDomain: "SEU_AUTH_DOMAIN",
    projectId: "SEU_PROJECT_ID",
    storageBucket: "SEU_BUCKET",
    messagingSenderId: "SEU_SENDER",
    appId: "SEU_APP_ID"
  };

  // Reutiliza app se já existir
  const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  // Persistência em sessão (facilita trocar de usuário)
  try { await setPersistence(auth, browserSessionPersistence); } catch (e) { console.warn("setPersistence:", e); }

  // ====== E-mails autorizados ======
  const AUTHORIZED_EMAILS = [
    "djmkbrasil@gmail.com",
    "frankokott@gmail.com",
    "djmkapple@gmail.com",
    "gabrielastephane11@gmail.com",
    "cibemarchi@gmail.com"
  ].map(e => e.toLowerCase());

  // ====== Caminho COMPARTILHADO ======
  const appId = firebaseConfig.appId;
  const fichasRef = collection(db, `artifacts/${appId}/shared/fichas`);

  // ====== Provider Google com seletor de conta ======
  const provider = new GoogleAuthProvider();
  provider.setCustomParameters({ prompt: "select_account" });

  // ====== Função de login (global) ======
  async function doGoogleLogin() {
    try {
      await signInWithPopup(auth, provider);
    } catch (e) {
      console.error("Erro no login Google:", e);
      const msg = (e && e.message) ? e.message : String(e);
      alert(
        "Erro ao entrar com Google:\n" + msg +
        "\n\nDicas:\n• Permita pop-ups para este site (ícone na barra de endereço)\n• Confirme se o authDomain nas credenciais do Firebase inclui o domínio onde está hospedado (ex.: djmkbrasil.github.io)"
      );
    }
  }
  // expõe globalmente (para onclick ou outros scripts)
  window.loginGoogle   = doGoogleLogin;
  window.login         = doGoogleLogin;
  window.signInGoogle  = doGoogleLogin;

  // ====== Bind automático em botões comuns (sem mexer no HTML) ======
  const selectors = [
    '#loginGoogle', '#btnGoogle', '#btnLogin', '#login',
    '.btn-login', 'button[data-login="google"]', 'a[data-login="google"]'
  ];
  function bindLoginButtons() {
    // por seletores explícitos
    selectors.forEach(sel => {
      document.querySelectorAll(sel).forEach(el => {
        if (el.__googleBind) return;
        el.__googleBind = true;
        el.addEventListener("click", (ev) => {
          ev.preventDefault?.();
          doGoogleLogin();
        });
      });
    });
  }
  // delegação global (casos em que o botão não tem ID/classe estável)
  function delegateByText(e) {
    const el = e.target.closest("button, a, .btn, [role='button']");
    if (!el) return;
    const txt = (el.innerText || el.textContent || "").toLowerCase().trim();
    // tenta casar textos típicos
    if (txt.includes("entrar com google") || txt.includes("login google") || txt.includes("google")) {
      e.preventDefault?.();
      doGoogleLogin();
    }
  }
  document.addEventListener("click", delegateByText, true);
  document.addEventListener("DOMContentLoaded", bindLoginButtons);
  setTimeout(bindLoginButtons, 800); // refaz bind se a UI montar depois

  // ====== Logout forte (mantém o que já tínhamos) ======
  async function hardLogout() {
    try { await fbSignOut(auth); } catch (e) { console.error(e); }
    // limpa storages/IndexedDB mínimos ligados ao Firebase para evitar reatachar
    try {
      const clearMatching = (s) => {
        const keys = [];
        for (let i = 0; i < s.length; i++) keys.push(s.key(i));
        keys.forEach(k => { if (k && (k.includes("firebase") || k.includes("g_state"))) { try { s.removeItem(k); } catch {} } });
      };
      clearMatching(window.localStorage);
      clearMatching(window.sessionStorage);
      if (window.indexedDB) {
        try { indexedDB.deleteDatabase("firebaseLocalStorageDb"); } catch {}
        try { indexedDB.deleteDatabase("firebase-installations-database"); } catch {}
        try { indexedDB.deleteDatabase("firebase-heartbeat-database"); } catch {}
      }
    } catch {}
    try { alert("Sessão encerrada."); } catch {}
    window.location.replace(window.location.pathname + window.location.search);
  }
  window.signOut = hardLogout;
  window.logout  = hardLogout;

  // ====== Gate por e-mail autorizado + leitura inicial ======
  onAuthStateChanged(auth, async (user) => {
    if (!user) return;
    const email = (user.email || "").toLowerCase();
    if (!AUTHORIZED_EMAILS.includes(email)) {
      await hardLogout();
      alert("Este e-mail não tem permissão de acesso. Use um e-mail autorizado.");
      return;
    }
    try {
      const q = query(fichasRef, orderBy("createdAt", "desc"));
      const snap = await getDocs(q);
      // TODO: chame aqui sua função de render original, se existir:
      // renderTabela(snap.docs.map(d => ({ id: d.id, ...d.data() })));
    } catch (e) {
      console.error(e);
      alert("Erro ao carregar fichas.");
    }
  });

  // ====== API pública para salvar (preservado) ======
  window.registrarFicha = async (payload) => {
    try {
      await addDoc(fichasRef, { ...payload, createdAt: serverTimestamp() });
      alert("Ficha registrada com sucesso!");
    } catch (e) {
      console.error(e);
      alert("Erro ao registrar ficha.");
    }
  };
</script>
